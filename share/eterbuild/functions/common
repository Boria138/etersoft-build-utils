#!/bin/bash
# 2003-2009 Etersoft www.etersoft.ru
# Author: Vitaly Lipatov <lav@etersoft.ru>
# Public domain

# $1 - needed VERSION of etersoft-build-utils. f.i. 162

set_eterbuilddir()
{
	[ -z "$ETERBUILDDIR" ] || return 0

	if dirname $0 | grep "^/usr" >/dev/null ; then
		ETERBUILDETC=/etc/eterbuild
		ETERBUILDDIR=/usr/share/eterbuild
	else
		# if run from no system installation
		# TODO: use real root dir not script dirname
		ETERBUILDDIR=$(realpath `dirname $0`/../share/eterbuild)
		ETERBUILDETC=$(realpath `dirname $0`/../etc)
		if [ -r "$ETERBUILDETC/../AUTHORS" ] ; then
			if [ -n "$VERBOSE" ] ; then
				echo "Note: run from source tree, datadir=$ETERBUILDDIR, sysconfdir=$ETERBUILDETC"
			fi
		else
			warning "Cannot find source tree root in source tree mode"
			ETERBUILDETC=/etc/eterbuild
			ETERBUILDDIR=/usr/share/eterbuild
		fi
	fi
	ETERBUILDBIN=$(realpath $ETERBUILDDIR/../../bin)
	test -n "$ETERBUILDDIR"
	# returns test result
}

# set if empty and check it
if ! set_eterbuilddir ; then
	echo "Can't detect package files location" >&2
	exit 1
fi

# Выводит указанное сообщение об ошибке и завершает программу
fatal()
{
	echog "Error: $@" >&2
	exit 1
}

# Выводит указанное сообщение
warning()
{
	echog "Warning: $@" >&2
}

print_list()
{
	local i
	for i in $@ ; do
		echo "    $i"
	done
}

get_root_git_dir()
{
        local DIR="$1"
        [ -n "$DIR" ] || DIR=$(pwd)
        [ "$DIR" = "/" ] && return 1
        if [ -d "$DIR/.git" ] ; then
                readlink -f "$DIR"
                return
        fi
        get_root_git_dir $(dirname "$DIR") || return 1
}

# Usage: is_gear [path_to_spec|dir_inside_git]
is_gear()
{
	local DIR="$1"
	[ -z "$IGNOREGEAR" ] || return 1
	[ -f "$DIR" ] && DIR=$(dirname "$DIR")
	local GITDIR=$(get_root_git_dir "$DIR")
	[ -d "$GITDIR/.gear" ] && return 0
	[ -r "$GITDIR/.gear-rules" ] && return 0
	return 1
}


if [ "$UID" = "0" ] ; then
	fatal "It is strict recommended do not use these scripts as root"
fi


load_mod()
{
	local i
	for i in $@ ; do
		. $ETERBUILDDIR/functions/$i
	done
}

load_mod config gettext alt spec

# check for needed version
if [ -n "$NEEDETERBUILD" ] ; then
	if [ "$NEEDETERBUILD" -gt "$ETERBUILDVERSION" ] ; then
		echo "Obsoleted version of etersoft-build-utils version is used. Please upgrade it to $NEEDETERBUILD version."
		exit 1
	fi
fi


# Internal
# Определяет, для какой среды собирать: по ключу -M23 -M24 или по каталогу, в котором спек
detect_target_env()
{
local DISTRNAME=`distr_vendor -e`
MENVARG=""
TARGET=`distr_vendor -p`
VENDOR=`distr_vendor -s`
RPMVENDOR=`distr_vendor -n`

if [ "$VENDOR" = "alt" ] && [ -n "$MENV" ] ; then
	[ -n "$APTCONF" ] || APTCONF=${APTCONFBASE/.SS}.$MENV
	
	[ -n "$VERBOSE" ] && echog "Target ALT Linux system: `get_altdistr_version $MENV`, use \$APTCONF"
	MENVARG="-$MENV"
else
	# FIXME: echog breakes vars
	echog "Distribution: \$DISTRNAME (\$VENDOR) (target package: \$TARGET)"
fi
}

# Отделяет файлы в LISTNAMES
# Отделяет указание среды в MENV
# Устанавливает LISTARGS в оставшиеся аргументы
# использование:
# - отделяем среду (MENV)
# - отделяем файлы
# - оставшееся обрабатываем как параметры программы
parse_cmd_pre()
{
local i
if [ $# -lt 1 ]; then
    [ -n "$Usage" ] && echog "$Usage"
	fatal "Use -h for help."
fi

# Sisyphus by default
MENV=SS
set_target_type $(basename `pwd`)

LISTNAMES=
LISTARGS=
OPTINDEX=1
for i in "$@"
do
	# Если файл существует, то добавляем, иначе считаем аргумент параметром.
	if [ -f "$i" ]; then
		# echo is workaround for missed readlink
		LISTNAMES="$LISTNAMES $(readlink -f $i 2>/dev/null | echo $i)"
	else
		set_target_type ${i/-/} || LISTARGS="$LISTARGS $i"
	fi
done
# remove extra space before list
LISTNAMES=$(echo "$LISTNAMES" | sed -e "s|^ ||")
LISTARGS=$(echo "$LISTARGS" | sed -e "s|^ ||")
# parse MENV
detect_target_env
[ -n "$VERBOSE" ] && echo "LISTNAMES=$LISTNAMES LISTARGS=$LISTARGS" || :
}

check_key()
{
	echog "Check access to SSH private key..."
	ssh-add -l || ssh-add $SSH_KEYFILE || return 1
	return 0
}

make_temp_file()
{
	# Workaround about broken mktemp
	if mktemp -V >/dev/null 2>/dev/null ; then
		mktemp || exit 1
	else
		mktemp /tmp/$1.XXXXXX || exit 1
	fi
}


is_ssh_target()
{
	echo "$1" | grep -q ":"
}

enable_ccache()
{
	which ccache >/dev/null || fatal "Install ccache package before using"

	# handled in gcc-common
	export GCC_USE_CCACHE=1
	# step to gcc-common
	export CC=gcc CXX=g++

	#export CC="ccache gcc"
	#export CPP="ccache gcc -E"
	#export CXX="ccache g++"
	#export CXXCPP="ccache g++ -E"

}

